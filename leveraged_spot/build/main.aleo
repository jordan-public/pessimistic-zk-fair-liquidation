import credits.aleo;
import token_registry.aleo;
program leveraged_spot.aleo;

record Voucher:
    owner as address.private;
    amount as u128.private;
    price as u128.private;
    collateral_amount as u128.private;
    block_no as u32.private;

struct TokenMetadata:
    token_id as field;
    name as u128;
    symbol as u128;
    decimals as u8;
    supply as u128;
    max_supply as u128;
    admin as address;
    external_authorization_required as boolean;
    external_authorization_party as address;

struct TokenOwner:
    account as address;
    token_id as field;

struct TimeSequence:
    start as u32;
    length as u32;

mapping low_watermarks:
    key as field.public;
    value as u128.public;

mapping spot_price:
    key as u8.public;
    value as u128.public;

function time_sequence_key:
    input r0 as u32.private;
    input r1 as u32.private;
    cast r0 r1 into r2 as TimeSequence;
    hash.bhp256 r2 into r3 as field;
    output r3 as field.private;

function spot_price_oracle:
    input r0 as u128.private;
    input r1 as u32.private;
    async spot_price_oracle r0 r1 into r2;
    output r2 as leveraged_spot.aleo/spot_price_oracle.future;

finalize spot_price_oracle:
    input r0 as u128.public;
    input r1 as u32.public;
    set r0 into spot_price[0u8];
    is.eq 0u32 0u32 into r2;
    rem r1 0u32 into r3;
    ternary r2 r1 r3 into r4;
    cast r4 0u32 into r5 as TimeSequence;
    hash.bhp256 r5 into r6 as field;
    get.or_use low_watermarks[r6] r0 into r7;
    lt r0 r7 into r8;
    branch.eq r8 false to end_then_0_0;
    set r0 into low_watermarks[r6];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;
    mul 0u32 10u32 into r9;
    is.eq r9 0u32 into r10;
    rem r1 r9 into r11;
    ternary r10 r1 r11 into r12;
    cast r12 r9 into r13 as TimeSequence;
    hash.bhp256 r13 into r14 as field;
    get.or_use low_watermarks[r14] r0 into r15;
    lt r0 r15 into r16;
    branch.eq r16 false to end_then_0_2;
    set r0 into low_watermarks[r14];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    position end_otherwise_0_3;
    mul r9 10u32 into r17;
    is.eq r17 0u32 into r18;
    rem r1 r17 into r19;
    ternary r18 r1 r19 into r20;
    cast r20 r17 into r21 as TimeSequence;
    hash.bhp256 r21 into r22 as field;
    get.or_use low_watermarks[r22] r0 into r23;
    lt r0 r23 into r24;
    branch.eq r24 false to end_then_0_4;
    set r0 into low_watermarks[r22];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    position end_otherwise_0_5;
    mul r17 10u32 into r25;
    is.eq r25 0u32 into r26;
    rem r1 r25 into r27;
    ternary r26 r1 r27 into r28;
    cast r28 r25 into r29 as TimeSequence;
    hash.bhp256 r29 into r30 as field;
    get.or_use low_watermarks[r30] r0 into r31;
    lt r0 r31 into r32;
    branch.eq r32 false to end_then_0_6;
    set r0 into low_watermarks[r30];
    branch.eq true true to end_otherwise_0_7;
    position end_then_0_6;
    position end_otherwise_0_7;
    mul r25 10u32 into r33;

function record_low_watermark:
    input r0 as u128.private;
    input r1 as u32.private;
    async record_low_watermark r0 r1 into r2;
    output r2 as leveraged_spot.aleo/record_low_watermark.future;

finalize record_low_watermark:
    input r0 as u128.public;
    input r1 as u32.public;
    is.eq 0u32 0u32 into r2;
    rem r1 0u32 into r3;
    ternary r2 r1 r3 into r4;
    cast r4 0u32 into r5 as TimeSequence;
    hash.bhp256 r5 into r6 as field;
    get.or_use low_watermarks[r6] r0 into r7;
    lt r0 r7 into r8;
    branch.eq r8 false to end_then_0_8;
    set r0 into low_watermarks[r6];
    branch.eq true true to end_otherwise_0_9;
    position end_then_0_8;
    position end_otherwise_0_9;
    is.eq 0u32 0u32 into r9;
    rem r1 0u32 into r10;
    ternary r9 r1 r10 into r11;
    cast r11 0u32 into r12 as TimeSequence;
    hash.bhp256 r12 into r13 as field;
    get.or_use low_watermarks[r13] r0 into r14;
    lt r0 r14 into r15;
    branch.eq r15 false to end_then_0_10;
    set r0 into low_watermarks[r13];
    branch.eq true true to end_otherwise_0_11;
    position end_then_0_10;
    position end_otherwise_0_11;
    is.eq 0u32 0u32 into r16;
    rem r1 0u32 into r17;
    ternary r16 r1 r17 into r18;
    cast r18 0u32 into r19 as TimeSequence;
    hash.bhp256 r19 into r20 as field;
    get.or_use low_watermarks[r20] r0 into r21;
    lt r0 r21 into r22;
    branch.eq r22 false to end_then_0_12;
    set r0 into low_watermarks[r20];
    branch.eq true true to end_otherwise_0_13;
    position end_then_0_12;
    position end_otherwise_0_13;
    is.eq 0u32 0u32 into r23;
    rem r1 0u32 into r24;
    ternary r23 r1 r24 into r25;
    cast r25 0u32 into r26 as TimeSequence;
    hash.bhp256 r26 into r27 as field;
    get.or_use low_watermarks[r27] r0 into r28;
    lt r0 r28 into r29;
    branch.eq r29 false to end_then_0_14;
    set r0 into low_watermarks[r27];
    branch.eq true true to end_otherwise_0_15;
    position end_then_0_14;
    position end_otherwise_0_15;

function buy:
    input r0 as u128.private;
    input r1 as u128.private;
    input r2 as token_registry.aleo/Token.record;
    input r3 as u128.private;
    input r4 as u32.private;
    call token_registry.aleo/burn_private r2 r3 into r5 r6;
    cast self.signer r0 r1 r3 r4 into r7 as Voucher.record;
    async buy r1 r4 r6 into r8;
    output r5 as token_registry.aleo/Token.record;
    output r7 as Voucher.record;
    output r8 as leveraged_spot.aleo/buy.future;

finalize buy:
    input r0 as u128.public;
    input r1 as u32.public;
    input r2 as token_registry.aleo/burn_private.future;
    await r2;
    is.eq 0u32 0u32 into r3;
    rem r1 0u32 into r4;
    ternary r3 r1 r4 into r5;
    cast r5 0u32 into r6 as TimeSequence;
    hash.bhp256 r6 into r7 as field;
    get.or_use low_watermarks[r7] r0 into r8;
    lt r0 r8 into r9;
    branch.eq r9 false to end_then_0_16;
    set r0 into low_watermarks[r7];
    branch.eq true true to end_otherwise_0_17;
    position end_then_0_16;
    position end_otherwise_0_17;
    is.eq 0u32 0u32 into r10;
    rem r1 0u32 into r11;
    ternary r10 r1 r11 into r12;
    cast r12 0u32 into r13 as TimeSequence;
    hash.bhp256 r13 into r14 as field;
    get.or_use low_watermarks[r14] r0 into r15;
    lt r0 r15 into r16;
    branch.eq r16 false to end_then_0_18;
    set r0 into low_watermarks[r14];
    branch.eq true true to end_otherwise_0_19;
    position end_then_0_18;
    position end_otherwise_0_19;
    is.eq 0u32 0u32 into r17;
    rem r1 0u32 into r18;
    ternary r17 r1 r18 into r19;
    cast r19 0u32 into r20 as TimeSequence;
    hash.bhp256 r20 into r21 as field;
    get.or_use low_watermarks[r21] r0 into r22;
    lt r0 r22 into r23;
    branch.eq r23 false to end_then_0_20;
    set r0 into low_watermarks[r21];
    branch.eq true true to end_otherwise_0_21;
    position end_then_0_20;
    position end_otherwise_0_21;
    is.eq 0u32 0u32 into r24;
    rem r1 0u32 into r25;
    ternary r24 r1 r25 into r26;
    cast r26 0u32 into r27 as TimeSequence;
    hash.bhp256 r27 into r28 as field;
    get.or_use low_watermarks[r28] r0 into r29;
    lt r0 r29 into r30;
    branch.eq r30 false to end_then_0_22;
    set r0 into low_watermarks[r28];
    branch.eq true true to end_otherwise_0_23;
    position end_then_0_22;
    position end_otherwise_0_23;

function sell:
    input r0 as Voucher.record;
    input r1 as u128.private;
    input r2 as u32.private;
    input r3 as [u32; 32u32].private;
    input r4 as [u32; 32u32].private;
    mul 1000000u128 r0.collateral_amount into r5;
    div r5 r0.amount into r6;
    gte r6 r0.price into r7;
    mul 1000000u128 r0.collateral_amount into r8;
    div r8 r0.amount into r9;
    sub r0.price r9 into r10;
    ternary r7 0u128 r10 into r11;
    gte r0.price r11 into r12;
    assert.eq r12 true;
    gte r1 r11 into r13;
    assert.eq r13 true;
    is.neq r3[0u32] 0u32 into r14;
    add r3[0u32] r4[0u32] into r15;
    is.eq r15 r3[1u32] into r16;
    not r14 into r17;
    or r16 r17 into r18;
    assert.eq r18 true;
    is.neq r3[1u32] 0u32 into r19;
    add r3[1u32] r4[1u32] into r20;
    is.eq r20 r3[2u32] into r21;
    not r19 into r22;
    or r21 r22 into r23;
    assert.eq r23 true;
    is.neq r3[2u32] 0u32 into r24;
    add r3[2u32] r4[2u32] into r25;
    is.eq r25 r3[3u32] into r26;
    not r24 into r27;
    or r26 r27 into r28;
    assert.eq r28 true;
    is.neq r3[3u32] 0u32 into r29;
    add r3[3u32] r4[3u32] into r30;
    is.eq r30 r3[4u32] into r31;
    not r29 into r32;
    or r31 r32 into r33;
    assert.eq r33 true;
    is.neq r3[4u32] 0u32 into r34;
    add r3[4u32] r4[4u32] into r35;
    is.eq r35 r3[5u32] into r36;
    not r34 into r37;
    or r36 r37 into r38;
    assert.eq r38 true;
    is.neq r3[5u32] 0u32 into r39;
    add r3[5u32] r4[5u32] into r40;
    is.eq r40 r3[6u32] into r41;
    not r39 into r42;
    or r41 r42 into r43;
    assert.eq r43 true;
    is.neq r3[6u32] 0u32 into r44;
    add r3[6u32] r4[6u32] into r45;
    is.eq r45 r3[7u32] into r46;
    not r44 into r47;
    or r46 r47 into r48;
    assert.eq r48 true;
    is.neq r3[7u32] 0u32 into r49;
    add r3[7u32] r4[7u32] into r50;
    is.eq r50 r3[8u32] into r51;
    not r49 into r52;
    or r51 r52 into r53;
    assert.eq r53 true;
    is.neq r3[8u32] 0u32 into r54;
    add r3[8u32] r4[8u32] into r55;
    is.eq r55 r3[9u32] into r56;
    not r54 into r57;
    or r56 r57 into r58;
    assert.eq r58 true;
    is.neq r3[9u32] 0u32 into r59;
    add r3[9u32] r4[9u32] into r60;
    is.eq r60 r3[10u32] into r61;
    not r59 into r62;
    or r61 r62 into r63;
    assert.eq r63 true;
    is.neq r3[10u32] 0u32 into r64;
    add r3[10u32] r4[10u32] into r65;
    is.eq r65 r3[11u32] into r66;
    not r64 into r67;
    or r66 r67 into r68;
    assert.eq r68 true;
    is.neq r3[11u32] 0u32 into r69;
    add r3[11u32] r4[11u32] into r70;
    is.eq r70 r3[12u32] into r71;
    not r69 into r72;
    or r71 r72 into r73;
    assert.eq r73 true;
    is.neq r3[12u32] 0u32 into r74;
    add r3[12u32] r4[12u32] into r75;
    is.eq r75 r3[13u32] into r76;
    not r74 into r77;
    or r76 r77 into r78;
    assert.eq r78 true;
    is.neq r3[13u32] 0u32 into r79;
    add r3[13u32] r4[13u32] into r80;
    is.eq r80 r3[14u32] into r81;
    not r79 into r82;
    or r81 r82 into r83;
    assert.eq r83 true;
    is.neq r3[14u32] 0u32 into r84;
    add r3[14u32] r4[14u32] into r85;
    is.eq r85 r3[15u32] into r86;
    not r84 into r87;
    or r86 r87 into r88;
    assert.eq r88 true;
    is.neq r3[15u32] 0u32 into r89;
    add r3[15u32] r4[15u32] into r90;
    is.eq r90 r3[16u32] into r91;
    not r89 into r92;
    or r91 r92 into r93;
    assert.eq r93 true;
    is.neq r3[16u32] 0u32 into r94;
    add r3[16u32] r4[16u32] into r95;
    is.eq r95 r3[17u32] into r96;
    not r94 into r97;
    or r96 r97 into r98;
    assert.eq r98 true;
    is.neq r3[17u32] 0u32 into r99;
    add r3[17u32] r4[17u32] into r100;
    is.eq r100 r3[18u32] into r101;
    not r99 into r102;
    or r101 r102 into r103;
    assert.eq r103 true;
    is.neq r3[18u32] 0u32 into r104;
    add r3[18u32] r4[18u32] into r105;
    is.eq r105 r3[19u32] into r106;
    not r104 into r107;
    or r106 r107 into r108;
    assert.eq r108 true;
    is.neq r3[19u32] 0u32 into r109;
    add r3[19u32] r4[19u32] into r110;
    is.eq r110 r3[20u32] into r111;
    not r109 into r112;
    or r111 r112 into r113;
    assert.eq r113 true;
    is.neq r3[20u32] 0u32 into r114;
    add r3[20u32] r4[20u32] into r115;
    is.eq r115 r3[21u32] into r116;
    not r114 into r117;
    or r116 r117 into r118;
    assert.eq r118 true;
    is.neq r3[21u32] 0u32 into r119;
    add r3[21u32] r4[21u32] into r120;
    is.eq r120 r3[22u32] into r121;
    not r119 into r122;
    or r121 r122 into r123;
    assert.eq r123 true;
    is.neq r3[22u32] 0u32 into r124;
    add r3[22u32] r4[22u32] into r125;
    is.eq r125 r3[23u32] into r126;
    not r124 into r127;
    or r126 r127 into r128;
    assert.eq r128 true;
    is.neq r3[23u32] 0u32 into r129;
    add r3[23u32] r4[23u32] into r130;
    is.eq r130 r3[24u32] into r131;
    not r129 into r132;
    or r131 r132 into r133;
    assert.eq r133 true;
    is.neq r3[24u32] 0u32 into r134;
    add r3[24u32] r4[24u32] into r135;
    is.eq r135 r3[25u32] into r136;
    not r134 into r137;
    or r136 r137 into r138;
    assert.eq r138 true;
    is.neq r3[25u32] 0u32 into r139;
    add r3[25u32] r4[25u32] into r140;
    is.eq r140 r3[26u32] into r141;
    not r139 into r142;
    or r141 r142 into r143;
    assert.eq r143 true;
    is.neq r3[26u32] 0u32 into r144;
    add r3[26u32] r4[26u32] into r145;
    is.eq r145 r3[27u32] into r146;
    not r144 into r147;
    or r146 r147 into r148;
    assert.eq r148 true;
    is.neq r3[27u32] 0u32 into r149;
    add r3[27u32] r4[27u32] into r150;
    is.eq r150 r3[28u32] into r151;
    not r149 into r152;
    or r151 r152 into r153;
    assert.eq r153 true;
    is.neq r3[28u32] 0u32 into r154;
    add r3[28u32] r4[28u32] into r155;
    is.eq r155 r3[29u32] into r156;
    not r154 into r157;
    or r156 r157 into r158;
    assert.eq r158 true;
    is.neq r3[29u32] 0u32 into r159;
    add r3[29u32] r4[29u32] into r160;
    is.eq r160 r3[30u32] into r161;
    not r159 into r162;
    or r161 r162 into r163;
    assert.eq r163 true;
    is.neq r3[30u32] 0u32 into r164;
    add r3[30u32] r4[30u32] into r165;
    is.eq r165 r3[31u32] into r166;
    not r164 into r167;
    or r166 r167 into r168;
    assert.eq r168 true;
    async sell r1 r2 r11 r3 r4 into r169;
    output r169 as leveraged_spot.aleo/sell.future;

finalize sell:
    input r0 as u128.public;
    input r1 as u32.public;
    input r2 as u128.public;
    input r3 as [u32; 32u32].public;
    input r4 as [u32; 32u32].public;
    is.neq r3[0u32] 0u32 into r5;
    branch.eq r5 false to end_then_0_24;
    cast r3[0u32] r4[0u32] into r6 as TimeSequence;
    hash.bhp256 r6 into r7 as field;
    get low_watermarks[r7] into r8;
    lte r2 r8 into r9;
    assert.eq r9 true;
    branch.eq true true to end_otherwise_0_25;
    position end_then_0_24;
    position end_otherwise_0_25;
    is.neq r3[1u32] 0u32 into r10;
    branch.eq r10 false to end_then_0_26;
    cast r3[1u32] r4[1u32] into r11 as TimeSequence;
    hash.bhp256 r11 into r12 as field;
    get low_watermarks[r12] into r13;
    lte r2 r13 into r14;
    assert.eq r14 true;
    branch.eq true true to end_otherwise_0_27;
    position end_then_0_26;
    position end_otherwise_0_27;
    is.neq r3[2u32] 0u32 into r15;
    branch.eq r15 false to end_then_0_28;
    cast r3[2u32] r4[2u32] into r16 as TimeSequence;
    hash.bhp256 r16 into r17 as field;
    get low_watermarks[r17] into r18;
    lte r2 r18 into r19;
    assert.eq r19 true;
    branch.eq true true to end_otherwise_0_29;
    position end_then_0_28;
    position end_otherwise_0_29;
    is.neq r3[3u32] 0u32 into r20;
    branch.eq r20 false to end_then_0_30;
    cast r3[3u32] r4[3u32] into r21 as TimeSequence;
    hash.bhp256 r21 into r22 as field;
    get low_watermarks[r22] into r23;
    lte r2 r23 into r24;
    assert.eq r24 true;
    branch.eq true true to end_otherwise_0_31;
    position end_then_0_30;
    position end_otherwise_0_31;
    is.neq r3[4u32] 0u32 into r25;
    branch.eq r25 false to end_then_0_32;
    cast r3[4u32] r4[4u32] into r26 as TimeSequence;
    hash.bhp256 r26 into r27 as field;
    get low_watermarks[r27] into r28;
    lte r2 r28 into r29;
    assert.eq r29 true;
    branch.eq true true to end_otherwise_0_33;
    position end_then_0_32;
    position end_otherwise_0_33;
    is.neq r3[5u32] 0u32 into r30;
    branch.eq r30 false to end_then_0_34;
    cast r3[5u32] r4[5u32] into r31 as TimeSequence;
    hash.bhp256 r31 into r32 as field;
    get low_watermarks[r32] into r33;
    lte r2 r33 into r34;
    assert.eq r34 true;
    branch.eq true true to end_otherwise_0_35;
    position end_then_0_34;
    position end_otherwise_0_35;
    is.neq r3[6u32] 0u32 into r35;
    branch.eq r35 false to end_then_0_36;
    cast r3[6u32] r4[6u32] into r36 as TimeSequence;
    hash.bhp256 r36 into r37 as field;
    get low_watermarks[r37] into r38;
    lte r2 r38 into r39;
    assert.eq r39 true;
    branch.eq true true to end_otherwise_0_37;
    position end_then_0_36;
    position end_otherwise_0_37;
    is.neq r3[7u32] 0u32 into r40;
    branch.eq r40 false to end_then_0_38;
    cast r3[7u32] r4[7u32] into r41 as TimeSequence;
    hash.bhp256 r41 into r42 as field;
    get low_watermarks[r42] into r43;
    lte r2 r43 into r44;
    assert.eq r44 true;
    branch.eq true true to end_otherwise_0_39;
    position end_then_0_38;
    position end_otherwise_0_39;
    is.neq r3[8u32] 0u32 into r45;
    branch.eq r45 false to end_then_0_40;
    cast r3[8u32] r4[8u32] into r46 as TimeSequence;
    hash.bhp256 r46 into r47 as field;
    get low_watermarks[r47] into r48;
    lte r2 r48 into r49;
    assert.eq r49 true;
    branch.eq true true to end_otherwise_0_41;
    position end_then_0_40;
    position end_otherwise_0_41;
    is.neq r3[9u32] 0u32 into r50;
    branch.eq r50 false to end_then_0_42;
    cast r3[9u32] r4[9u32] into r51 as TimeSequence;
    hash.bhp256 r51 into r52 as field;
    get low_watermarks[r52] into r53;
    lte r2 r53 into r54;
    assert.eq r54 true;
    branch.eq true true to end_otherwise_0_43;
    position end_then_0_42;
    position end_otherwise_0_43;
    is.neq r3[10u32] 0u32 into r55;
    branch.eq r55 false to end_then_0_44;
    cast r3[10u32] r4[10u32] into r56 as TimeSequence;
    hash.bhp256 r56 into r57 as field;
    get low_watermarks[r57] into r58;
    lte r2 r58 into r59;
    assert.eq r59 true;
    branch.eq true true to end_otherwise_0_45;
    position end_then_0_44;
    position end_otherwise_0_45;
    is.neq r3[11u32] 0u32 into r60;
    branch.eq r60 false to end_then_0_46;
    cast r3[11u32] r4[11u32] into r61 as TimeSequence;
    hash.bhp256 r61 into r62 as field;
    get low_watermarks[r62] into r63;
    lte r2 r63 into r64;
    assert.eq r64 true;
    branch.eq true true to end_otherwise_0_47;
    position end_then_0_46;
    position end_otherwise_0_47;
    is.neq r3[12u32] 0u32 into r65;
    branch.eq r65 false to end_then_0_48;
    cast r3[12u32] r4[12u32] into r66 as TimeSequence;
    hash.bhp256 r66 into r67 as field;
    get low_watermarks[r67] into r68;
    lte r2 r68 into r69;
    assert.eq r69 true;
    branch.eq true true to end_otherwise_0_49;
    position end_then_0_48;
    position end_otherwise_0_49;
    is.neq r3[13u32] 0u32 into r70;
    branch.eq r70 false to end_then_0_50;
    cast r3[13u32] r4[13u32] into r71 as TimeSequence;
    hash.bhp256 r71 into r72 as field;
    get low_watermarks[r72] into r73;
    lte r2 r73 into r74;
    assert.eq r74 true;
    branch.eq true true to end_otherwise_0_51;
    position end_then_0_50;
    position end_otherwise_0_51;
    is.neq r3[14u32] 0u32 into r75;
    branch.eq r75 false to end_then_0_52;
    cast r3[14u32] r4[14u32] into r76 as TimeSequence;
    hash.bhp256 r76 into r77 as field;
    get low_watermarks[r77] into r78;
    lte r2 r78 into r79;
    assert.eq r79 true;
    branch.eq true true to end_otherwise_0_53;
    position end_then_0_52;
    position end_otherwise_0_53;
    is.neq r3[15u32] 0u32 into r80;
    branch.eq r80 false to end_then_0_54;
    cast r3[15u32] r4[15u32] into r81 as TimeSequence;
    hash.bhp256 r81 into r82 as field;
    get low_watermarks[r82] into r83;
    lte r2 r83 into r84;
    assert.eq r84 true;
    branch.eq true true to end_otherwise_0_55;
    position end_then_0_54;
    position end_otherwise_0_55;
    is.neq r3[16u32] 0u32 into r85;
    branch.eq r85 false to end_then_0_56;
    cast r3[16u32] r4[16u32] into r86 as TimeSequence;
    hash.bhp256 r86 into r87 as field;
    get low_watermarks[r87] into r88;
    lte r2 r88 into r89;
    assert.eq r89 true;
    branch.eq true true to end_otherwise_0_57;
    position end_then_0_56;
    position end_otherwise_0_57;
    is.neq r3[17u32] 0u32 into r90;
    branch.eq r90 false to end_then_0_58;
    cast r3[17u32] r4[17u32] into r91 as TimeSequence;
    hash.bhp256 r91 into r92 as field;
    get low_watermarks[r92] into r93;
    lte r2 r93 into r94;
    assert.eq r94 true;
    branch.eq true true to end_otherwise_0_59;
    position end_then_0_58;
    position end_otherwise_0_59;
    is.neq r3[18u32] 0u32 into r95;
    branch.eq r95 false to end_then_0_60;
    cast r3[18u32] r4[18u32] into r96 as TimeSequence;
    hash.bhp256 r96 into r97 as field;
    get low_watermarks[r97] into r98;
    lte r2 r98 into r99;
    assert.eq r99 true;
    branch.eq true true to end_otherwise_0_61;
    position end_then_0_60;
    position end_otherwise_0_61;
    is.neq r3[19u32] 0u32 into r100;
    branch.eq r100 false to end_then_0_62;
    cast r3[19u32] r4[19u32] into r101 as TimeSequence;
    hash.bhp256 r101 into r102 as field;
    get low_watermarks[r102] into r103;
    lte r2 r103 into r104;
    assert.eq r104 true;
    branch.eq true true to end_otherwise_0_63;
    position end_then_0_62;
    position end_otherwise_0_63;
    is.neq r3[20u32] 0u32 into r105;
    branch.eq r105 false to end_then_0_64;
    cast r3[20u32] r4[20u32] into r106 as TimeSequence;
    hash.bhp256 r106 into r107 as field;
    get low_watermarks[r107] into r108;
    lte r2 r108 into r109;
    assert.eq r109 true;
    branch.eq true true to end_otherwise_0_65;
    position end_then_0_64;
    position end_otherwise_0_65;
    is.neq r3[21u32] 0u32 into r110;
    branch.eq r110 false to end_then_0_66;
    cast r3[21u32] r4[21u32] into r111 as TimeSequence;
    hash.bhp256 r111 into r112 as field;
    get low_watermarks[r112] into r113;
    lte r2 r113 into r114;
    assert.eq r114 true;
    branch.eq true true to end_otherwise_0_67;
    position end_then_0_66;
    position end_otherwise_0_67;
    is.neq r3[22u32] 0u32 into r115;
    branch.eq r115 false to end_then_0_68;
    cast r3[22u32] r4[22u32] into r116 as TimeSequence;
    hash.bhp256 r116 into r117 as field;
    get low_watermarks[r117] into r118;
    lte r2 r118 into r119;
    assert.eq r119 true;
    branch.eq true true to end_otherwise_0_69;
    position end_then_0_68;
    position end_otherwise_0_69;
    is.neq r3[23u32] 0u32 into r120;
    branch.eq r120 false to end_then_0_70;
    cast r3[23u32] r4[23u32] into r121 as TimeSequence;
    hash.bhp256 r121 into r122 as field;
    get low_watermarks[r122] into r123;
    lte r2 r123 into r124;
    assert.eq r124 true;
    branch.eq true true to end_otherwise_0_71;
    position end_then_0_70;
    position end_otherwise_0_71;
    is.neq r3[24u32] 0u32 into r125;
    branch.eq r125 false to end_then_0_72;
    cast r3[24u32] r4[24u32] into r126 as TimeSequence;
    hash.bhp256 r126 into r127 as field;
    get low_watermarks[r127] into r128;
    lte r2 r128 into r129;
    assert.eq r129 true;
    branch.eq true true to end_otherwise_0_73;
    position end_then_0_72;
    position end_otherwise_0_73;
    is.neq r3[25u32] 0u32 into r130;
    branch.eq r130 false to end_then_0_74;
    cast r3[25u32] r4[25u32] into r131 as TimeSequence;
    hash.bhp256 r131 into r132 as field;
    get low_watermarks[r132] into r133;
    lte r2 r133 into r134;
    assert.eq r134 true;
    branch.eq true true to end_otherwise_0_75;
    position end_then_0_74;
    position end_otherwise_0_75;
    is.neq r3[26u32] 0u32 into r135;
    branch.eq r135 false to end_then_0_76;
    cast r3[26u32] r4[26u32] into r136 as TimeSequence;
    hash.bhp256 r136 into r137 as field;
    get low_watermarks[r137] into r138;
    lte r2 r138 into r139;
    assert.eq r139 true;
    branch.eq true true to end_otherwise_0_77;
    position end_then_0_76;
    position end_otherwise_0_77;
    is.neq r3[27u32] 0u32 into r140;
    branch.eq r140 false to end_then_0_78;
    cast r3[27u32] r4[27u32] into r141 as TimeSequence;
    hash.bhp256 r141 into r142 as field;
    get low_watermarks[r142] into r143;
    lte r2 r143 into r144;
    assert.eq r144 true;
    branch.eq true true to end_otherwise_0_79;
    position end_then_0_78;
    position end_otherwise_0_79;
    is.neq r3[28u32] 0u32 into r145;
    branch.eq r145 false to end_then_0_80;
    cast r3[28u32] r4[28u32] into r146 as TimeSequence;
    hash.bhp256 r146 into r147 as field;
    get low_watermarks[r147] into r148;
    lte r2 r148 into r149;
    assert.eq r149 true;
    branch.eq true true to end_otherwise_0_81;
    position end_then_0_80;
    position end_otherwise_0_81;
    is.neq r3[29u32] 0u32 into r150;
    branch.eq r150 false to end_then_0_82;
    cast r3[29u32] r4[29u32] into r151 as TimeSequence;
    hash.bhp256 r151 into r152 as field;
    get low_watermarks[r152] into r153;
    lte r2 r153 into r154;
    assert.eq r154 true;
    branch.eq true true to end_otherwise_0_83;
    position end_then_0_82;
    position end_otherwise_0_83;
    is.neq r3[30u32] 0u32 into r155;
    branch.eq r155 false to end_then_0_84;
    cast r3[30u32] r4[30u32] into r156 as TimeSequence;
    hash.bhp256 r156 into r157 as field;
    get low_watermarks[r157] into r158;
    lte r2 r158 into r159;
    assert.eq r159 true;
    branch.eq true true to end_otherwise_0_85;
    position end_then_0_84;
    position end_otherwise_0_85;
    is.neq r3[31u32] 0u32 into r160;
    branch.eq r160 false to end_then_0_86;
    cast r3[31u32] r4[31u32] into r161 as TimeSequence;
    hash.bhp256 r161 into r162 as field;
    get low_watermarks[r162] into r163;
    lte r2 r163 into r164;
    assert.eq r164 true;
    branch.eq true true to end_otherwise_0_87;
    position end_then_0_86;
    position end_otherwise_0_87;

function main:
    input r0 as u32.public;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;
