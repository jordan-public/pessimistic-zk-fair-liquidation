import credits.aleo;
import token_registry.aleo;
program leveraged_spot.aleo;

record Voucher:
    owner as address.private;
    amount as u128.private;
    price as u128.private;
    collateral_amount as u128.private;
    block_no as u32.private;

struct TokenMetadata:
    token_id as field;
    name as u128;
    symbol as u128;
    decimals as u8;
    supply as u128;
    max_supply as u128;
    admin as address;
    external_authorization_required as boolean;
    external_authorization_party as address;

struct TokenOwner:
    account as address;
    token_id as field;

struct TimeSequence:
    start as u32;
    length as u32;

mapping low_watermarks:
    key as field.public;
    value as u128.public;

mapping spot_price:
    key as u8.public;
    value as u128.public;

function initialize:
    call token_registry.aleo/register_token 4086179070172029689989191504251673329323324697790262897954312563933915289279field 318453955671054116610412u128 1129270348u128 6u8 10000000000000000u128 false leveraged_spot.aleo into r0;
    div 10000000000000000u128 10u128 into r1;
    call token_registry.aleo/mint_public 4086179070172029689989191504251673329323324697790262897954312563933915289279field self.caller 10000000000000000u128 0u32 into r2;
    async initialize r0 r2 self.caller into r3;
    output r3 as leveraged_spot.aleo/initialize.future;

finalize initialize:
    input r0 as token_registry.aleo/register_token.future;
    input r1 as token_registry.aleo/mint_public.future;
    input r2 as address.public;
    await r0;
    await r1;

function time_sequence_key:
    input r0 as u32.private;
    input r1 as u32.private;
    cast r0 r1 into r2 as TimeSequence;
    hash.bhp256 r2 into r3 as field;
    output r3 as field.private;

function spot_price_oracle:
    input r0 as u128.private;
    input r1 as u32.private;
    async spot_price_oracle r0 r1 into r2;
    output r2 as leveraged_spot.aleo/spot_price_oracle.future;

finalize spot_price_oracle:
    input r0 as u128.public;
    input r1 as u32.public;
    set r0 into spot_price[0u8];
    is.eq 0u32 0u32 into r2;
    rem r1 0u32 into r3;
    ternary r2 r1 r3 into r4;
    cast r4 0u32 into r5 as TimeSequence;
    hash.bhp256 r5 into r6 as field;
    get.or_use low_watermarks[r6] r0 into r7;
    lt r0 r7 into r8;
    branch.eq r8 false to end_then_0_0;
    set r0 into low_watermarks[r6];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;
    mul 0u32 10u32 into r9;
    is.eq r9 0u32 into r10;
    rem r1 r9 into r11;
    ternary r10 r1 r11 into r12;
    cast r12 r9 into r13 as TimeSequence;
    hash.bhp256 r13 into r14 as field;
    get.or_use low_watermarks[r14] r0 into r15;
    lt r0 r15 into r16;
    branch.eq r16 false to end_then_0_2;
    set r0 into low_watermarks[r14];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    position end_otherwise_0_3;
    mul r9 10u32 into r17;
    is.eq r17 0u32 into r18;
    rem r1 r17 into r19;
    ternary r18 r1 r19 into r20;
    cast r20 r17 into r21 as TimeSequence;
    hash.bhp256 r21 into r22 as field;
    get.or_use low_watermarks[r22] r0 into r23;
    lt r0 r23 into r24;
    branch.eq r24 false to end_then_0_4;
    set r0 into low_watermarks[r22];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    position end_otherwise_0_5;
    mul r17 10u32 into r25;
    is.eq r25 0u32 into r26;
    rem r1 r25 into r27;
    ternary r26 r1 r27 into r28;
    cast r28 r25 into r29 as TimeSequence;
    hash.bhp256 r29 into r30 as field;
    get.or_use low_watermarks[r30] r0 into r31;
    lt r0 r31 into r32;
    branch.eq r32 false to end_then_0_6;
    set r0 into low_watermarks[r30];
    branch.eq true true to end_otherwise_0_7;
    position end_then_0_6;
    position end_otherwise_0_7;
    mul r25 10u32 into r33;

function record_low_watermark:
    input r0 as u128.private;
    input r1 as u32.private;
    async record_low_watermark r0 r1 into r2;
    output r2 as leveraged_spot.aleo/record_low_watermark.future;

finalize record_low_watermark:
    input r0 as u128.public;
    input r1 as u32.public;
    is.eq 0u32 0u32 into r2;
    rem r1 0u32 into r3;
    ternary r2 r1 r3 into r4;
    cast r4 0u32 into r5 as TimeSequence;
    hash.bhp256 r5 into r6 as field;
    get.or_use low_watermarks[r6] r0 into r7;
    lt r0 r7 into r8;
    branch.eq r8 false to end_then_0_8;
    set r0 into low_watermarks[r6];
    branch.eq true true to end_otherwise_0_9;
    position end_then_0_8;
    position end_otherwise_0_9;
    is.eq 0u32 0u32 into r9;
    rem r1 0u32 into r10;
    ternary r9 r1 r10 into r11;
    cast r11 0u32 into r12 as TimeSequence;
    hash.bhp256 r12 into r13 as field;
    get.or_use low_watermarks[r13] r0 into r14;
    lt r0 r14 into r15;
    branch.eq r15 false to end_then_0_10;
    set r0 into low_watermarks[r13];
    branch.eq true true to end_otherwise_0_11;
    position end_then_0_10;
    position end_otherwise_0_11;
    is.eq 0u32 0u32 into r16;
    rem r1 0u32 into r17;
    ternary r16 r1 r17 into r18;
    cast r18 0u32 into r19 as TimeSequence;
    hash.bhp256 r19 into r20 as field;
    get.or_use low_watermarks[r20] r0 into r21;
    lt r0 r21 into r22;
    branch.eq r22 false to end_then_0_12;
    set r0 into low_watermarks[r20];
    branch.eq true true to end_otherwise_0_13;
    position end_then_0_12;
    position end_otherwise_0_13;
    is.eq 0u32 0u32 into r23;
    rem r1 0u32 into r24;
    ternary r23 r1 r24 into r25;
    cast r25 0u32 into r26 as TimeSequence;
    hash.bhp256 r26 into r27 as field;
    get.or_use low_watermarks[r27] r0 into r28;
    lt r0 r28 into r29;
    branch.eq r29 false to end_then_0_14;
    set r0 into low_watermarks[r27];
    branch.eq true true to end_otherwise_0_15;
    position end_then_0_14;
    position end_otherwise_0_15;

function buy:
    input r0 as u128.private;
    input r1 as u128.private;
    input r2 as token_registry.aleo/Token.record;
    input r3 as u128.private;
    input r4 as u32.private;
    call token_registry.aleo/burn_private r2 r3 into r5 r6;
    cast self.signer r0 r1 r3 r4 into r7 as Voucher.record;
    async buy r1 r4 r6 into r8;
    output r5 as token_registry.aleo/Token.record;
    output r7 as Voucher.record;
    output r8 as leveraged_spot.aleo/buy.future;

finalize buy:
    input r0 as u128.public;
    input r1 as u32.public;
    input r2 as token_registry.aleo/burn_private.future;
    await r2;
    is.eq 0u32 0u32 into r3;
    rem r1 0u32 into r4;
    ternary r3 r1 r4 into r5;
    cast r5 0u32 into r6 as TimeSequence;
    hash.bhp256 r6 into r7 as field;
    get.or_use low_watermarks[r7] r0 into r8;
    lt r0 r8 into r9;
    branch.eq r9 false to end_then_0_16;
    set r0 into low_watermarks[r7];
    branch.eq true true to end_otherwise_0_17;
    position end_then_0_16;
    position end_otherwise_0_17;
    is.eq 0u32 0u32 into r10;
    rem r1 0u32 into r11;
    ternary r10 r1 r11 into r12;
    cast r12 0u32 into r13 as TimeSequence;
    hash.bhp256 r13 into r14 as field;
    get.or_use low_watermarks[r14] r0 into r15;
    lt r0 r15 into r16;
    branch.eq r16 false to end_then_0_18;
    set r0 into low_watermarks[r14];
    branch.eq true true to end_otherwise_0_19;
    position end_then_0_18;
    position end_otherwise_0_19;
    is.eq 0u32 0u32 into r17;
    rem r1 0u32 into r18;
    ternary r17 r1 r18 into r19;
    cast r19 0u32 into r20 as TimeSequence;
    hash.bhp256 r20 into r21 as field;
    get.or_use low_watermarks[r21] r0 into r22;
    lt r0 r22 into r23;
    branch.eq r23 false to end_then_0_20;
    set r0 into low_watermarks[r21];
    branch.eq true true to end_otherwise_0_21;
    position end_then_0_20;
    position end_otherwise_0_21;
    is.eq 0u32 0u32 into r24;
    rem r1 0u32 into r25;
    ternary r24 r1 r25 into r26;
    cast r26 0u32 into r27 as TimeSequence;
    hash.bhp256 r27 into r28 as field;
    get.or_use low_watermarks[r28] r0 into r29;
    lt r0 r29 into r30;
    branch.eq r30 false to end_then_0_22;
    set r0 into low_watermarks[r28];
    branch.eq true true to end_otherwise_0_23;
    position end_then_0_22;
    position end_otherwise_0_23;

function sell:
    input r0 as Voucher.record;
    input r1 as u128.private;
    input r2 as u32.private;
    input r3 as [u32; 32u32].private;
    input r4 as [u32; 32u32].private;
    mul 1000000u128 r0.collateral_amount into r5;
    div r5 r0.amount into r6;
    gte r6 r0.price into r7;
    mul 1000000u128 r0.collateral_amount into r8;
    div r8 r0.amount into r9;
    sub r0.price r9 into r10;
    ternary r7 0u128 r10 into r11;
    gte r0.price r11 into r12;
    assert.eq r12 true;
    gte r1 r11 into r13;
    assert.eq r13 true;
    is.neq r3[0u32] 0u32 into r14;
    add r3[0u32] r4[0u32] into r15;
    is.eq r15 r3[1u32] into r16;
    not r14 into r17;
    or r16 r17 into r18;
    assert.eq r18 true;
    is.neq r3[1u32] 0u32 into r19;
    add r3[1u32] r4[1u32] into r20;
    is.eq r20 r3[2u32] into r21;
    not r19 into r22;
    or r21 r22 into r23;
    assert.eq r23 true;
    is.neq r3[2u32] 0u32 into r24;
    add r3[2u32] r4[2u32] into r25;
    is.eq r25 r3[3u32] into r26;
    not r24 into r27;
    or r26 r27 into r28;
    assert.eq r28 true;
    is.neq r3[3u32] 0u32 into r29;
    add r3[3u32] r4[3u32] into r30;
    is.eq r30 r3[4u32] into r31;
    not r29 into r32;
    or r31 r32 into r33;
    assert.eq r33 true;
    is.neq r3[4u32] 0u32 into r34;
    add r3[4u32] r4[4u32] into r35;
    is.eq r35 r3[5u32] into r36;
    not r34 into r37;
    or r36 r37 into r38;
    assert.eq r38 true;
    is.neq r3[5u32] 0u32 into r39;
    add r3[5u32] r4[5u32] into r40;
    is.eq r40 r3[6u32] into r41;
    not r39 into r42;
    or r41 r42 into r43;
    assert.eq r43 true;
    is.neq r3[6u32] 0u32 into r44;
    add r3[6u32] r4[6u32] into r45;
    is.eq r45 r3[7u32] into r46;
    not r44 into r47;
    or r46 r47 into r48;
    assert.eq r48 true;
    is.neq r3[7u32] 0u32 into r49;
    add r3[7u32] r4[7u32] into r50;
    is.eq r50 r3[8u32] into r51;
    not r49 into r52;
    or r51 r52 into r53;
    assert.eq r53 true;
    is.neq r3[8u32] 0u32 into r54;
    add r3[8u32] r4[8u32] into r55;
    is.eq r55 r3[9u32] into r56;
    not r54 into r57;
    or r56 r57 into r58;
    assert.eq r58 true;
    is.neq r3[9u32] 0u32 into r59;
    add r3[9u32] r4[9u32] into r60;
    is.eq r60 r3[10u32] into r61;
    not r59 into r62;
    or r61 r62 into r63;
    assert.eq r63 true;
    is.neq r3[10u32] 0u32 into r64;
    add r3[10u32] r4[10u32] into r65;
    is.eq r65 r3[11u32] into r66;
    not r64 into r67;
    or r66 r67 into r68;
    assert.eq r68 true;
    is.neq r3[11u32] 0u32 into r69;
    add r3[11u32] r4[11u32] into r70;
    is.eq r70 r3[12u32] into r71;
    not r69 into r72;
    or r71 r72 into r73;
    assert.eq r73 true;
    is.neq r3[12u32] 0u32 into r74;
    add r3[12u32] r4[12u32] into r75;
    is.eq r75 r3[13u32] into r76;
    not r74 into r77;
    or r76 r77 into r78;
    assert.eq r78 true;
    is.neq r3[13u32] 0u32 into r79;
    add r3[13u32] r4[13u32] into r80;
    is.eq r80 r3[14u32] into r81;
    not r79 into r82;
    or r81 r82 into r83;
    assert.eq r83 true;
    is.neq r3[14u32] 0u32 into r84;
    add r3[14u32] r4[14u32] into r85;
    is.eq r85 r3[15u32] into r86;
    not r84 into r87;
    or r86 r87 into r88;
    assert.eq r88 true;
    is.neq r3[15u32] 0u32 into r89;
    add r3[15u32] r4[15u32] into r90;
    is.eq r90 r3[16u32] into r91;
    not r89 into r92;
    or r91 r92 into r93;
    assert.eq r93 true;
    is.neq r3[16u32] 0u32 into r94;
    add r3[16u32] r4[16u32] into r95;
    is.eq r95 r3[17u32] into r96;
    not r94 into r97;
    or r96 r97 into r98;
    assert.eq r98 true;
    is.neq r3[17u32] 0u32 into r99;
    add r3[17u32] r4[17u32] into r100;
    is.eq r100 r3[18u32] into r101;
    not r99 into r102;
    or r101 r102 into r103;
    assert.eq r103 true;
    is.neq r3[18u32] 0u32 into r104;
    add r3[18u32] r4[18u32] into r105;
    is.eq r105 r3[19u32] into r106;
    not r104 into r107;
    or r106 r107 into r108;
    assert.eq r108 true;
    is.neq r3[19u32] 0u32 into r109;
    add r3[19u32] r4[19u32] into r110;
    is.eq r110 r3[20u32] into r111;
    not r109 into r112;
    or r111 r112 into r113;
    assert.eq r113 true;
    is.neq r3[20u32] 0u32 into r114;
    add r3[20u32] r4[20u32] into r115;
    is.eq r115 r3[21u32] into r116;
    not r114 into r117;
    or r116 r117 into r118;
    assert.eq r118 true;
    is.neq r3[21u32] 0u32 into r119;
    add r3[21u32] r4[21u32] into r120;
    is.eq r120 r3[22u32] into r121;
    not r119 into r122;
    or r121 r122 into r123;
    assert.eq r123 true;
    is.neq r3[22u32] 0u32 into r124;
    add r3[22u32] r4[22u32] into r125;
    is.eq r125 r3[23u32] into r126;
    not r124 into r127;
    or r126 r127 into r128;
    assert.eq r128 true;
    is.neq r3[23u32] 0u32 into r129;
    add r3[23u32] r4[23u32] into r130;
    is.eq r130 r3[24u32] into r131;
    not r129 into r132;
    or r131 r132 into r133;
    assert.eq r133 true;
    is.neq r3[24u32] 0u32 into r134;
    add r3[24u32] r4[24u32] into r135;
    is.eq r135 r3[25u32] into r136;
    not r134 into r137;
    or r136 r137 into r138;
    assert.eq r138 true;
    is.neq r3[25u32] 0u32 into r139;
    add r3[25u32] r4[25u32] into r140;
    is.eq r140 r3[26u32] into r141;
    not r139 into r142;
    or r141 r142 into r143;
    assert.eq r143 true;
    is.neq r3[26u32] 0u32 into r144;
    add r3[26u32] r4[26u32] into r145;
    is.eq r145 r3[27u32] into r146;
    not r144 into r147;
    or r146 r147 into r148;
    assert.eq r148 true;
    is.neq r3[27u32] 0u32 into r149;
    add r3[27u32] r4[27u32] into r150;
    is.eq r150 r3[28u32] into r151;
    not r149 into r152;
    or r151 r152 into r153;
    assert.eq r153 true;
    is.neq r3[28u32] 0u32 into r154;
    add r3[28u32] r4[28u32] into r155;
    is.eq r155 r3[29u32] into r156;
    not r154 into r157;
    or r156 r157 into r158;
    assert.eq r158 true;
    is.neq r3[29u32] 0u32 into r159;
    add r3[29u32] r4[29u32] into r160;
    is.eq r160 r3[30u32] into r161;
    not r159 into r162;
    or r161 r162 into r163;
    assert.eq r163 true;
    is.neq r3[30u32] 0u32 into r164;
    add r3[30u32] r4[30u32] into r165;
    is.eq r165 r3[31u32] into r166;
    not r164 into r167;
    or r166 r167 into r168;
    assert.eq r168 true;
    sub r1 r0.price into r169;
    mul r169 r0.amount into r170;
    div r170 1000000u128 into r171;
    add r0.amount r171 into r172;
    call token_registry.aleo/mint_private 4086179070172029689989191504251673329323324697790262897954312563933915289279field r0.owner r172 false 0u32 into r173 r174;
    async sell r174 r1 r2 r11 r3 r4 into r175;
    output r173 as token_registry.aleo/Token.record;
    output r175 as leveraged_spot.aleo/sell.future;

finalize sell:
    input r0 as token_registry.aleo/mint_private.future;
    input r1 as u128.public;
    input r2 as u32.public;
    input r3 as u128.public;
    input r4 as [u32; 32u32].public;
    input r5 as [u32; 32u32].public;
    is.neq r4[0u32] 0u32 into r6;
    branch.eq r6 false to end_then_0_24;
    cast r4[0u32] r5[0u32] into r7 as TimeSequence;
    hash.bhp256 r7 into r8 as field;
    get low_watermarks[r8] into r9;
    lte r3 r9 into r10;
    assert.eq r10 true;
    branch.eq true true to end_otherwise_0_25;
    position end_then_0_24;
    position end_otherwise_0_25;
    is.neq r4[1u32] 0u32 into r11;
    branch.eq r11 false to end_then_0_26;
    cast r4[1u32] r5[1u32] into r12 as TimeSequence;
    hash.bhp256 r12 into r13 as field;
    get low_watermarks[r13] into r14;
    lte r3 r14 into r15;
    assert.eq r15 true;
    branch.eq true true to end_otherwise_0_27;
    position end_then_0_26;
    position end_otherwise_0_27;
    is.neq r4[2u32] 0u32 into r16;
    branch.eq r16 false to end_then_0_28;
    cast r4[2u32] r5[2u32] into r17 as TimeSequence;
    hash.bhp256 r17 into r18 as field;
    get low_watermarks[r18] into r19;
    lte r3 r19 into r20;
    assert.eq r20 true;
    branch.eq true true to end_otherwise_0_29;
    position end_then_0_28;
    position end_otherwise_0_29;
    is.neq r4[3u32] 0u32 into r21;
    branch.eq r21 false to end_then_0_30;
    cast r4[3u32] r5[3u32] into r22 as TimeSequence;
    hash.bhp256 r22 into r23 as field;
    get low_watermarks[r23] into r24;
    lte r3 r24 into r25;
    assert.eq r25 true;
    branch.eq true true to end_otherwise_0_31;
    position end_then_0_30;
    position end_otherwise_0_31;
    is.neq r4[4u32] 0u32 into r26;
    branch.eq r26 false to end_then_0_32;
    cast r4[4u32] r5[4u32] into r27 as TimeSequence;
    hash.bhp256 r27 into r28 as field;
    get low_watermarks[r28] into r29;
    lte r3 r29 into r30;
    assert.eq r30 true;
    branch.eq true true to end_otherwise_0_33;
    position end_then_0_32;
    position end_otherwise_0_33;
    is.neq r4[5u32] 0u32 into r31;
    branch.eq r31 false to end_then_0_34;
    cast r4[5u32] r5[5u32] into r32 as TimeSequence;
    hash.bhp256 r32 into r33 as field;
    get low_watermarks[r33] into r34;
    lte r3 r34 into r35;
    assert.eq r35 true;
    branch.eq true true to end_otherwise_0_35;
    position end_then_0_34;
    position end_otherwise_0_35;
    is.neq r4[6u32] 0u32 into r36;
    branch.eq r36 false to end_then_0_36;
    cast r4[6u32] r5[6u32] into r37 as TimeSequence;
    hash.bhp256 r37 into r38 as field;
    get low_watermarks[r38] into r39;
    lte r3 r39 into r40;
    assert.eq r40 true;
    branch.eq true true to end_otherwise_0_37;
    position end_then_0_36;
    position end_otherwise_0_37;
    is.neq r4[7u32] 0u32 into r41;
    branch.eq r41 false to end_then_0_38;
    cast r4[7u32] r5[7u32] into r42 as TimeSequence;
    hash.bhp256 r42 into r43 as field;
    get low_watermarks[r43] into r44;
    lte r3 r44 into r45;
    assert.eq r45 true;
    branch.eq true true to end_otherwise_0_39;
    position end_then_0_38;
    position end_otherwise_0_39;
    is.neq r4[8u32] 0u32 into r46;
    branch.eq r46 false to end_then_0_40;
    cast r4[8u32] r5[8u32] into r47 as TimeSequence;
    hash.bhp256 r47 into r48 as field;
    get low_watermarks[r48] into r49;
    lte r3 r49 into r50;
    assert.eq r50 true;
    branch.eq true true to end_otherwise_0_41;
    position end_then_0_40;
    position end_otherwise_0_41;
    is.neq r4[9u32] 0u32 into r51;
    branch.eq r51 false to end_then_0_42;
    cast r4[9u32] r5[9u32] into r52 as TimeSequence;
    hash.bhp256 r52 into r53 as field;
    get low_watermarks[r53] into r54;
    lte r3 r54 into r55;
    assert.eq r55 true;
    branch.eq true true to end_otherwise_0_43;
    position end_then_0_42;
    position end_otherwise_0_43;
    is.neq r4[10u32] 0u32 into r56;
    branch.eq r56 false to end_then_0_44;
    cast r4[10u32] r5[10u32] into r57 as TimeSequence;
    hash.bhp256 r57 into r58 as field;
    get low_watermarks[r58] into r59;
    lte r3 r59 into r60;
    assert.eq r60 true;
    branch.eq true true to end_otherwise_0_45;
    position end_then_0_44;
    position end_otherwise_0_45;
    is.neq r4[11u32] 0u32 into r61;
    branch.eq r61 false to end_then_0_46;
    cast r4[11u32] r5[11u32] into r62 as TimeSequence;
    hash.bhp256 r62 into r63 as field;
    get low_watermarks[r63] into r64;
    lte r3 r64 into r65;
    assert.eq r65 true;
    branch.eq true true to end_otherwise_0_47;
    position end_then_0_46;
    position end_otherwise_0_47;
    is.neq r4[12u32] 0u32 into r66;
    branch.eq r66 false to end_then_0_48;
    cast r4[12u32] r5[12u32] into r67 as TimeSequence;
    hash.bhp256 r67 into r68 as field;
    get low_watermarks[r68] into r69;
    lte r3 r69 into r70;
    assert.eq r70 true;
    branch.eq true true to end_otherwise_0_49;
    position end_then_0_48;
    position end_otherwise_0_49;
    is.neq r4[13u32] 0u32 into r71;
    branch.eq r71 false to end_then_0_50;
    cast r4[13u32] r5[13u32] into r72 as TimeSequence;
    hash.bhp256 r72 into r73 as field;
    get low_watermarks[r73] into r74;
    lte r3 r74 into r75;
    assert.eq r75 true;
    branch.eq true true to end_otherwise_0_51;
    position end_then_0_50;
    position end_otherwise_0_51;
    is.neq r4[14u32] 0u32 into r76;
    branch.eq r76 false to end_then_0_52;
    cast r4[14u32] r5[14u32] into r77 as TimeSequence;
    hash.bhp256 r77 into r78 as field;
    get low_watermarks[r78] into r79;
    lte r3 r79 into r80;
    assert.eq r80 true;
    branch.eq true true to end_otherwise_0_53;
    position end_then_0_52;
    position end_otherwise_0_53;
    is.neq r4[15u32] 0u32 into r81;
    branch.eq r81 false to end_then_0_54;
    cast r4[15u32] r5[15u32] into r82 as TimeSequence;
    hash.bhp256 r82 into r83 as field;
    get low_watermarks[r83] into r84;
    lte r3 r84 into r85;
    assert.eq r85 true;
    branch.eq true true to end_otherwise_0_55;
    position end_then_0_54;
    position end_otherwise_0_55;
    is.neq r4[16u32] 0u32 into r86;
    branch.eq r86 false to end_then_0_56;
    cast r4[16u32] r5[16u32] into r87 as TimeSequence;
    hash.bhp256 r87 into r88 as field;
    get low_watermarks[r88] into r89;
    lte r3 r89 into r90;
    assert.eq r90 true;
    branch.eq true true to end_otherwise_0_57;
    position end_then_0_56;
    position end_otherwise_0_57;
    is.neq r4[17u32] 0u32 into r91;
    branch.eq r91 false to end_then_0_58;
    cast r4[17u32] r5[17u32] into r92 as TimeSequence;
    hash.bhp256 r92 into r93 as field;
    get low_watermarks[r93] into r94;
    lte r3 r94 into r95;
    assert.eq r95 true;
    branch.eq true true to end_otherwise_0_59;
    position end_then_0_58;
    position end_otherwise_0_59;
    is.neq r4[18u32] 0u32 into r96;
    branch.eq r96 false to end_then_0_60;
    cast r4[18u32] r5[18u32] into r97 as TimeSequence;
    hash.bhp256 r97 into r98 as field;
    get low_watermarks[r98] into r99;
    lte r3 r99 into r100;
    assert.eq r100 true;
    branch.eq true true to end_otherwise_0_61;
    position end_then_0_60;
    position end_otherwise_0_61;
    is.neq r4[19u32] 0u32 into r101;
    branch.eq r101 false to end_then_0_62;
    cast r4[19u32] r5[19u32] into r102 as TimeSequence;
    hash.bhp256 r102 into r103 as field;
    get low_watermarks[r103] into r104;
    lte r3 r104 into r105;
    assert.eq r105 true;
    branch.eq true true to end_otherwise_0_63;
    position end_then_0_62;
    position end_otherwise_0_63;
    is.neq r4[20u32] 0u32 into r106;
    branch.eq r106 false to end_then_0_64;
    cast r4[20u32] r5[20u32] into r107 as TimeSequence;
    hash.bhp256 r107 into r108 as field;
    get low_watermarks[r108] into r109;
    lte r3 r109 into r110;
    assert.eq r110 true;
    branch.eq true true to end_otherwise_0_65;
    position end_then_0_64;
    position end_otherwise_0_65;
    is.neq r4[21u32] 0u32 into r111;
    branch.eq r111 false to end_then_0_66;
    cast r4[21u32] r5[21u32] into r112 as TimeSequence;
    hash.bhp256 r112 into r113 as field;
    get low_watermarks[r113] into r114;
    lte r3 r114 into r115;
    assert.eq r115 true;
    branch.eq true true to end_otherwise_0_67;
    position end_then_0_66;
    position end_otherwise_0_67;
    is.neq r4[22u32] 0u32 into r116;
    branch.eq r116 false to end_then_0_68;
    cast r4[22u32] r5[22u32] into r117 as TimeSequence;
    hash.bhp256 r117 into r118 as field;
    get low_watermarks[r118] into r119;
    lte r3 r119 into r120;
    assert.eq r120 true;
    branch.eq true true to end_otherwise_0_69;
    position end_then_0_68;
    position end_otherwise_0_69;
    is.neq r4[23u32] 0u32 into r121;
    branch.eq r121 false to end_then_0_70;
    cast r4[23u32] r5[23u32] into r122 as TimeSequence;
    hash.bhp256 r122 into r123 as field;
    get low_watermarks[r123] into r124;
    lte r3 r124 into r125;
    assert.eq r125 true;
    branch.eq true true to end_otherwise_0_71;
    position end_then_0_70;
    position end_otherwise_0_71;
    is.neq r4[24u32] 0u32 into r126;
    branch.eq r126 false to end_then_0_72;
    cast r4[24u32] r5[24u32] into r127 as TimeSequence;
    hash.bhp256 r127 into r128 as field;
    get low_watermarks[r128] into r129;
    lte r3 r129 into r130;
    assert.eq r130 true;
    branch.eq true true to end_otherwise_0_73;
    position end_then_0_72;
    position end_otherwise_0_73;
    is.neq r4[25u32] 0u32 into r131;
    branch.eq r131 false to end_then_0_74;
    cast r4[25u32] r5[25u32] into r132 as TimeSequence;
    hash.bhp256 r132 into r133 as field;
    get low_watermarks[r133] into r134;
    lte r3 r134 into r135;
    assert.eq r135 true;
    branch.eq true true to end_otherwise_0_75;
    position end_then_0_74;
    position end_otherwise_0_75;
    is.neq r4[26u32] 0u32 into r136;
    branch.eq r136 false to end_then_0_76;
    cast r4[26u32] r5[26u32] into r137 as TimeSequence;
    hash.bhp256 r137 into r138 as field;
    get low_watermarks[r138] into r139;
    lte r3 r139 into r140;
    assert.eq r140 true;
    branch.eq true true to end_otherwise_0_77;
    position end_then_0_76;
    position end_otherwise_0_77;
    is.neq r4[27u32] 0u32 into r141;
    branch.eq r141 false to end_then_0_78;
    cast r4[27u32] r5[27u32] into r142 as TimeSequence;
    hash.bhp256 r142 into r143 as field;
    get low_watermarks[r143] into r144;
    lte r3 r144 into r145;
    assert.eq r145 true;
    branch.eq true true to end_otherwise_0_79;
    position end_then_0_78;
    position end_otherwise_0_79;
    is.neq r4[28u32] 0u32 into r146;
    branch.eq r146 false to end_then_0_80;
    cast r4[28u32] r5[28u32] into r147 as TimeSequence;
    hash.bhp256 r147 into r148 as field;
    get low_watermarks[r148] into r149;
    lte r3 r149 into r150;
    assert.eq r150 true;
    branch.eq true true to end_otherwise_0_81;
    position end_then_0_80;
    position end_otherwise_0_81;
    is.neq r4[29u32] 0u32 into r151;
    branch.eq r151 false to end_then_0_82;
    cast r4[29u32] r5[29u32] into r152 as TimeSequence;
    hash.bhp256 r152 into r153 as field;
    get low_watermarks[r153] into r154;
    lte r3 r154 into r155;
    assert.eq r155 true;
    branch.eq true true to end_otherwise_0_83;
    position end_then_0_82;
    position end_otherwise_0_83;
    is.neq r4[30u32] 0u32 into r156;
    branch.eq r156 false to end_then_0_84;
    cast r4[30u32] r5[30u32] into r157 as TimeSequence;
    hash.bhp256 r157 into r158 as field;
    get low_watermarks[r158] into r159;
    lte r3 r159 into r160;
    assert.eq r160 true;
    branch.eq true true to end_otherwise_0_85;
    position end_then_0_84;
    position end_otherwise_0_85;
    is.neq r4[31u32] 0u32 into r161;
    branch.eq r161 false to end_then_0_86;
    cast r4[31u32] r5[31u32] into r162 as TimeSequence;
    hash.bhp256 r162 into r163 as field;
    get low_watermarks[r163] into r164;
    lte r3 r164 into r165;
    assert.eq r165 true;
    branch.eq true true to end_otherwise_0_87;
    position end_then_0_86;
    position end_otherwise_0_87;
    await r0;

function main:
    input r0 as u32.public;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;
